import { EventEmitter, Component, Input, Output, Inject, NgModule } from '@angular/core';
import { moveItemInArray, DragDropModule } from '@angular/cdk/drag-drop';
import { BehaviorSubject, of } from 'rxjs';
import { HttpParams } from '@angular/common/http';
import { FormGroup, FormControl, FormsModule, ReactiveFormsModule } from '@angular/forms';
import { MatDialogRef, MAT_DIALOG_DATA, MatDialogModule } from '@angular/material/dialog';
import { catchError, finalize } from 'rxjs/operators';
import { CommonModule } from '@angular/common';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatMenuModule } from '@angular/material/menu';
import { MatTableModule } from '@angular/material/table';
import { MatPaginatorModule } from '@angular/material/paginator';
import { OverlayModule } from '@angular/cdk/overlay';
import { MatSelectModule } from '@angular/material/select';
import { MatListModule } from '@angular/material/list';
import { MatCheckboxModule } from '@angular/material/checkbox';
import { MatSortModule } from '@angular/material/sort';
import { MatInputModule } from '@angular/material/input';
import { MatDatepickerModule } from '@angular/material/datepicker';
import { MatChipsModule } from '@angular/material/chips';
import { MatProgressBarModule } from '@angular/material/progress-bar';

class ColumnSelectorComponent {
    constructor() {
        this.menuVisible = false;
        this.columns = [];
        this.columnsChange = new EventEmitter();
        this.selectedColumns = [];
        this.selectedColumnsChange = new EventEmitter();
    }
    ngOnInit() { }
    toggleSelector() {
        this.menuVisible = !this.menuVisible;
    }
    // On backdrop click close the menu and send selectedColumnsChange event
    closeMenu() {
        this.menuVisible = false;
        this.selectedColumnsChange.emit(this.selectedColumns);
    }
    // After drop the array is reordered
    drop(event) {
        const previousColumn = this.columns[event.previousIndex];
        const currentColumn = this.columns[event.currentIndex];
        moveItemInArray(this.columns, event.previousIndex, event.currentIndex);
        const previousSelectIndex = this.selectedColumns.indexOf(previousColumn.key);
        const currentSelectIndex = this.selectedColumns.indexOf(currentColumn.key);
        if (previousSelectIndex != -1 && currentSelectIndex != -1) {
            moveItemInArray(this.selectedColumns, previousSelectIndex, currentSelectIndex);
        }
    }
}
ColumnSelectorComponent.decorators = [
    { type: Component, args: [{
                selector: 'column-selector',
                template: "<button\r\n    mat-icon-button\r\n    color=\"primary\"\r\n    (click)=\"toggleSelector()\"\r\n    cdkOverlayOrigin #trigger=\"cdkOverlayOrigin\">\r\n    <mat-icon aria-label=\"Columns\">view_column</mat-icon>\r\n</button>\r\n<ng-template\r\n  cdkConnectedOverlay\r\n  [cdkConnectedOverlayOrigin]=\"trigger\"\r\n  [cdkConnectedOverlayOpen]=\"menuVisible\"\r\n  [cdkConnectedOverlayHasBackdrop]=\"true\"\r\n  (backdropClick)=\"closeMenu()\">\r\n    <mat-selection-list class=\"column-list mat-elevation-z8\"\r\n        [(ngModel)]=\"selectedColumns\"\r\n        cdkDropList  (cdkDropListDropped)=\"drop($event)\">\r\n        <mat-list-option *ngFor=\"let column of columns\" \r\n            class=\"column-item\" \r\n            checkboxPosition=\"before\"  \r\n            [disabled]=\"column.locked\"\r\n            [value]=\"column.key\"\r\n            cdkDrag>\r\n            <div class=\"columnItem\">\r\n              <span>{{column.label}} </span>\r\n              <mat-icon>drag_handle</mat-icon>\r\n            </div>\r\n          </mat-list-option>\r\n    </mat-selection-list>\r\n</ng-template>\r\n",
                styles: [".column-list{min-width:200px;max-width:100%;border:1px solid #ccc;max-height:350px;display:block;background:#eee;overflow-y:auto}.cdk-drag-preview{display:flex;height:48px;-webkit-tap-highlight-color:transparent;width:100%;padding:0;position:relative}.cdk-drag-placeholder{opacity:0}.cdk-drag-animating{transition:transform .25s cubic-bezier(0,0,.2,1)}.columnItem{display:flex;justify-content:space-between}.columnItem mat-icon{cursor:-webkit-grab;cursor:grab}"]
            },] }
];
ColumnSelectorComponent.ctorParameters = () => [];
ColumnSelectorComponent.propDecorators = {
    columns: [{ type: Input }],
    columnsChange: [{ type: Output }],
    selectedColumns: [{ type: Input }],
    selectedColumnsChange: [{ type: Output }]
};

class Filter {
    constructor(key, label, type, options) {
        this.value = null;
        this.disabled = false;
        this.key = key;
        this.label = label;
        this.type = type;
        if (options)
            this.options = options.map((value) => {
                if (typeof value === 'string') {
                    return { id: value, label: value };
                }
                return value;
            });
    }
}
var FilterType;
(function (FilterType) {
    FilterType["TEXT"] = "TEXT";
    FilterType["SELECT"] = "SELECT";
    FilterType["DATE"] = "DATE";
})(FilterType || (FilterType = {}));
/**
 * Track the current datatable filter status with :
 * - an array of applicable filters with their value
 * - the current pagination status
 * - the current sort field
 */
class FilterSet {
    constructor() {
        // Applicable filters
        this.filters = {};
        // Pagination
        this.limit = 10;
        this.page = null; // Zero based
        // Sorting
        this.sortField = null;
        this.sortDirection = 'Desc';
    }
    find(key) { return this.filters[key]; }
    add(filter) { this.filters[filter.key] = filter; }
    remove(key) { delete this.filters[key]; }
    isActive() { return this.getActiveFilters().length > 0; }
    clear() {
        Object.keys(this.filters).forEach(key => {
            this.filters[key].value = null;
        });
    }
    reset() { this.filters = {}; }
    getActiveFilters() {
        return Object.values(this.filters).filter(f => (f.value !== null && f.value !== undefined));
    }
    getParams() {
        console.log(this);
        let params = new HttpParams();
        if (this.page !== null) {
            params = params.append('page', this.page.toString());
            params = params.append('limit', this.limit.toString());
        }
        if (this.sortField) {
            params = params.append('sort', this.sortField.toString());
            params = params.append('direction', this.sortDirection.toString());
        }
        if (this.filters) {
            this.getActiveFilters().forEach((filter) => params = params.append(filter.key, filter.value));
        }
        return params;
    }
    setSort(field, direction) {
        this.sortField = field;
        this.sortDirection = direction;
        this.resetPage();
    }
    resetPage() {
        if (this.page)
            this.page = 0;
    }
}

class ColumnFilterService {
    constructor() {
        this.filterSet = new FilterSet();
        this.filterSetSubject = new BehaviorSubject(this.filterSet);
        this.filterSet$ = this.filterSetSubject.asObservable();
    }
    emitFilters() { this.filterSetSubject.next(this.filterSet); }
    // Filters methods  
    addFilter(key, label, type, options) {
        this.filterSet.add(new Filter(key, label, type, options));
        this.emitFilters();
    }
    removeFilter(key) {
        this.filterSet.remove(key);
        this.emitFilters();
    }
    setFilter(key, value) {
        let filter = this.filterSet.find(key);
        if (filter) {
            filter.value = value;
            this.emitFilters();
        }
    }
    clearFilter(key) { this.setFilter(key, null); }
    updateFilters(filterSet) {
        this.filterSet = filterSet;
        this.emitFilters();
    }
    isActive() {
        return this.filterSet.isActive();
    }
    disableFilter(key) {
        let filter = this.filterSet.find(key);
        if (filter) {
            filter.disabled = true;
            this.emitFilters();
        }
    }
    enableFilter(key) {
        let filter = this.filterSet.find(key);
        if (filter) {
            filter.disabled = false;
            this.emitFilters();
        }
    }
    clearFilters() {
        this.filterSet.clear();
        this.emitFilters();
    }
    // Paging methods
    setPage(page, limit) {
        this.filterSet.page = page;
        if (limit)
            this.filterSet.limit = limit;
        this.emitFilters();
    }
    setLimit(limit) {
        this.filterSet.limit = limit;
        this.emitFilters();
    }
    // Sorting methods
    setSort(field, direction) {
        this.filterSet.sortField = field;
        this.filterSet.sortDirection = direction;
        this.emitFilters();
    }
}

class ChipsFilterComponent {
    constructor(filtersService) {
        this.filtersService = filtersService;
        this.chips = [];
        this.filtersService.filterSet$
            .subscribe(filterSet => this.chips = filterSet.getActiveFilters());
    }
    clear(key) { this.filtersService.clearFilter(key); }
    clearFilters() { this.filtersService.clearFilters(); }
}
ChipsFilterComponent.decorators = [
    { type: Component, args: [{
                selector: 'stam-chips-filter',
                template: "<div class=\"infobox-container\" *ngIf=\"chips.length\">\r\n    <div class=\"mat-header-cell filter-header-label\" >Filtri attivi : </div>\r\n    <mat-chip-list>\r\n        <mat-chip *ngFor=\"let chip of chips\" \r\n            color=\"primary\"\r\n            selected=\"true\"\r\n            (removed)=\"clear(chip.key)\">\r\n            <mat-icon matChipRemove>cancel</mat-icon>\r\n            {{chip.label}} <span class=\"chipValue\">{{chip.value}}</span>\r\n        </mat-chip>\r\n    </mat-chip-list>\r\n    <div class=\"action-container\">\r\n        <button mat-button color=\"accent\" (click)=\"clearFilters()\">Cancella filtri</button>\r\n    </div>\r\n</div>\r\n\r\n",
                styles: [".infobox-container{display:flex;align-items:center;min-height:56px;width:100%;background:#fff;border-bottom:1px solid rgba(0,0,0,.12)}.infobox-container .filter-header-label{width:8em;margin:0 24px}.infobox-container mat-chip-list{flex-grow:1;margin:1em 0}.infobox-container mat-chip-list .chipValue{background-color:hsla(0,0%,100%,.5);padding:7px 16px;border-radius:16px;margin-left:8px;margin-right:-12px;line-height:19px;max-width:8em;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}.infobox-container mat-chip-list mat-icon{margin-left:0!important;margin-right:8px!important}"]
            },] }
];
ChipsFilterComponent.ctorParameters = () => [
    { type: ColumnFilterService }
];

class DialogFilterComponent {
    constructor(dialog, data) {
        this.dialog = dialog;
        this.data = data;
        this.filtersForm = new FormGroup({});
        this.filtersService = data.filtersService;
        this.filtersService.filterSet$.subscribe(filterSet => {
            this.filterSet = filterSet;
            Object.keys(this.filterSet.filters).forEach(key => this.filtersForm.addControl(key, new FormControl({ value: this.filterSet.filters[key].value, disabled: this.filterSet.filters[key].disabled })));
        });
    }
    clearFilters() {
        this.filtersForm.reset();
    }
    search() {
        Object.keys(this.filtersForm.controls).forEach(control => {
            const filter = this.filterSet.find(control);
            if (filter)
                filter.value = this.filtersForm.controls[control].value;
        });
        this.filterSet.resetPage();
        this.filtersService.updateFilters(this.filterSet);
        this.dialog.close();
    }
}
DialogFilterComponent.decorators = [
    { type: Component, args: [{
                selector: 'app-dialog-filter',
                template: "<h2 mat-dialog-title>Filtri</h2>\r\n<div mat-dialog-content>\r\n    <form [formGroup]=\"filtersForm\">        \r\n        <div *ngFor=\"let filter of filterSet.filters | keyvalue\">\r\n            <ng-container [ngSwitch]=\"filter.value.type\">\r\n                <ng-container *ngSwitchCase=\"'TEXT'\">\r\n                    <mat-form-field>\r\n                        <mat-label>{{ filter.value.label }}</mat-label>\r\n                        <input matInput [formControlName]=\"filter.key\">\r\n                    </mat-form-field>\r\n                </ng-container>\r\n                <ng-container *ngSwitchCase=\"'SELECT'\">\r\n                    <mat-form-field>\r\n                        <mat-label>{{ filter.value.label }}</mat-label>\r\n                        <mat-select [formControlName]=\"filter.key\">\r\n                            <mat-option [value]=\"\">---</mat-option> \r\n                            <mat-option *ngFor=\"let opt of filter.value.options\" [value]=\"opt.id\">\r\n                                {{ opt.label }}\r\n                            </mat-option>\r\n                        </mat-select>\r\n                    </mat-form-field>\r\n                </ng-container>\r\n                <ng-container *ngSwitchCase=\"'DATE'\">\r\n                    <mat-form-field>\r\n                        <mat-label>{{ filter.value.label }}</mat-label>\r\n                        <input matInput [matDatepicker]=\"picker\" [formControlName]=\"filter.key\">\r\n                        <mat-datepicker-toggle matSuffix [for]=\"picker\"></mat-datepicker-toggle>\r\n                        <mat-datepicker #picker></mat-datepicker>\r\n                    </mat-form-field>\r\n                </ng-container>\r\n            </ng-container>\r\n        </div>\r\n    </form>\r\n</div>\r\n<mat-dialog-actions align=\"end\">\r\n    <button class=\"clear-filters-button\" mat-raised-button (click)=\"clearFilters()\">Reset</button>\r\n    <button class=\"search-filters-button\" mat-raised-button color=\"primary\" (click)=\"search()\">Ricerca</button>\r\n</mat-dialog-actions>",
                styles: [".mat-form-field { width: 100% }"]
            },] }
];
DialogFilterComponent.ctorParameters = () => [
    { type: MatDialogRef },
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] }
];

class DatatableColumn {
    constructor(key, label) {
        this.key = key;
        this.label = label;
        this.visible = true;
        this.locked = false;
        this.customContent = false;
        this.sortable = key;
    }
}

class ColumnsManagerService {
    constructor() {
        this.columns = {};
    }
    addColumn(key, label) {
        this.columns[key] = new DatatableColumn(key, label);
    }
    setVisible(keys, value = true) { keys.forEach(k => { this.columns[k].visible = value; }); }
    setLocked(keys, value = true) { keys.forEach(k => { this.columns[k].locked = value; }); }
    setCustom(keys, value = true) { keys.forEach(k => { this.columns[k].customContent = value; }); }
    setSortable(keys, sortKey = "") { keys.forEach(k => { this.columns[k].sortable = sortKey; }); }
    // Get all columns
    getColumns() {
        return Object.values(this.columns);
    }
    // Get only visible columns
    getDisplayedColumns() {
        return Object.values(this.columns).filter(c => c.visible).map(c => c.key);
    }
    // Get only standard columns ( the content is simply the value )
    getStandardColumns() {
        return Object.values(this.columns).filter(c => !c.customContent);
    }
}

class RowsResponse {
    constructor() {
        this.content = [];
        this.totalElements = 0;
    }
}

class DatatableDatasource {
    constructor(rowsService) {
        this.rowsService = rowsService;
        this.rows = new BehaviorSubject([]);
        this.loadingSubject = new BehaviorSubject(false);
        this.loading$ = this.loadingSubject.asObservable();
        this.countSubject = new BehaviorSubject(0);
        this.counter$ = this.countSubject.asObservable();
    }
    connect(collectionViewer) {
        return this.rows.asObservable();
    }
    disconnect(collectionViewer) {
        this.rows.complete();
        this.loadingSubject.complete();
        this.countSubject.complete();
    }
    loadData(filterSet) {
        this.loadingSubject.next(true);
        this.rowsService.findAll(filterSet)
            .pipe(catchError(() => of(new RowsResponse())), finalize(() => this.loadingSubject.next(false)))
            .subscribe((result) => {
            this.rows.next(result.content);
            this.countSubject.next(result.totalElements);
        });
    }
}

class StamDatatableModule {
}
StamDatatableModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    ColumnSelectorComponent,
                    DialogFilterComponent,
                    ChipsFilterComponent,
                ],
                imports: [
                    CommonModule,
                    MatDatepickerModule,
                    MatInputModule,
                    FormsModule,
                    ReactiveFormsModule,
                    MatMenuModule,
                    MatIconModule,
                    //MatBadgeModule,
                    MatButtonModule,
                    //MatTooltipModule,
                    //MatToolbarModule,
                    OverlayModule,
                    MatTableModule,
                    MatPaginatorModule,
                    MatSelectModule,
                    DragDropModule,
                    MatListModule,
                    MatCheckboxModule,
                    MatSortModule,
                    MatDialogModule,
                    MatChipsModule,
                    MatProgressBarModule
                ],
                exports: [
                    ColumnSelectorComponent,
                    DialogFilterComponent,
                    ChipsFilterComponent
                ]
            },] }
];

/*
 * Public API Surface of datatable-utils
 */

/**
 * Generated bundle index. Do not edit.
 */

export { ChipsFilterComponent, ColumnFilterService, ColumnSelectorComponent, ColumnsManagerService, DatatableColumn, DatatableDatasource, DialogFilterComponent, Filter, FilterSet, FilterType, RowsResponse, StamDatatableModule };
//# sourceMappingURL=stamtech-datatable-utils.js.map
